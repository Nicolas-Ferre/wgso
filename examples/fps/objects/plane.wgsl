#mod main

const PLANE_POSITION = vec3f(0, 0, 0);
const PLANE_SIZE = vec2f(10, 10);

struct Plane {
    _phantom: f32,
}

#mod compute
#import ~.main

fn init_plane() -> Plane {
    return Plane(0);
}

#shader<render, Vertex, Plane> render
#import ~.main
#import objects.camera.main
#import _.std.math.constant
#import _.std.math.matrix
#import _.std.io.main
#import _.std.vertex.transform
#import _.std.vertex.type

const PLANE_COLOR = vec4f(1, 1, 1, 1);

var<uniform> camera: Camera;
var<uniform> surface: Surface;

struct Fragment {
    @builtin(position)
    position: vec4f,
    @location(0)
    relative_position: vec2f,
}

@vertex
fn vs_main(vertex: Vertex, instance: Plane) -> Fragment {
    let projection = proj_mat(surface.size, camera.fov, camera.far, camera.near);
    let view = view_mat(camera.position, vec3f(1, 1, 1), camera.rotation);
    let model = model_mat(PLANE_POSITION, vec3f(PLANE_SIZE, 1), quat(vec3f(1, 0, 0), PI / 2));
    let position = projection * view * model * vec4f(vertex.position, 1);
    return Fragment(position, vertex.position.xy);
}

// Will give a grass effect.
// Note: this code has been generated by ChatGPT.
@fragment
fn fs_main(frag: Fragment) -> @location(0) vec4f {
    let uv = frag.relative_position + vec2f(0.5); // range [0, 1]

    // Scale up for noise detail
    let n1 = noise(uv * 20);
    let n2 = noise(uv * 60);
    let n3 = noise(uv * 100);
    let n4 = noise(uv * 200);
    let n = (n1 * 0.5 + n2 * 0.3 + n3 * 0.2 + n4 * 0.1);

    // Base grass color with slight variation
    let base = vec3f(0.07, 0.5, 0.07);
    let highlight = vec3f(0.2, 0.8, 0.2);
    let color = mix(base, highlight, n);

    return vec4f(color, 1);
}

fn hash(p: vec2f) -> f32 {
    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453123);
}

fn noise(p: vec2f) -> f32 {
    let i = floor(p);
    let f = fract(p);
    let a = hash(i);
    let b = hash(i + vec2f(1, 0));
    let c = hash(i + vec2f(0, 1));
    let d = hash(i + vec2f(1, 1));
    let u = f * f * (3 - 2 * f);
    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
}
